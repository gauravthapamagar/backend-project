////////How to setup professional backend project//////////

/////// While learning
1. Take notes 
2. Focus on concepts
3. Ask questions
4. Experiment independently
5. Use tools like console.log for debugging
6. Practice basics in parallel like CRUD apps: todolist, blog apps
npm init : initializes node package manager (creates package.json)
/////////////


create public folder and create temp folder inside it
.gitkeep: it keeps track of the empty folders 

create gitignore
gitignore: it will not push sensitive files and the files that are not ment to be seen
you can search gitignore generator and can copy paste based on preferred language from there

create .env
.env: during production they are taken from system to make secure

create source (src)
src: contains all the work files 
    create file inside src folder
You can create through right click or simply goto terminal / bash
    cd src
    ls
    touch app.js constants.js index.js

JavaScipt has two types of importing: common js and module js 

now change the package.json and add type: module.js to work according with module with consistency through the project

when server file needs to be reload we have to start and stop the server , here we use nodemon
nodemon: it restarts the server whenever file gets saved. (but we have to tell it.)
goto scripts in package.json "scripts": "nodemon src/index.js

difference between dependency and dev dependency: 
dev dependency: used in the development, not used in the production 

now create proper folder using professional structure in the source folder..
goto src and create: 
mkdir controllers
(It would consist majorly functionalities)
mkdir db
(Here we write how to connect to the database)
mkdir middlewares 
(These are the codes that run in between request and response)
mkdir models
(defines structure of the data and how it interacts with the database)
mkdir routes
(defines the paths and endpoints of the application)
mkdir utils
(It contains reusable functionalities that performs common tasks)

after that goto nodemon and install prettier from there
vs code prettier is not recommended because while pushing the code in the git it causes so many conflicts.
Ex: some may write semicolons other may not, spaces etc
It tells which type of formatting we are using 

after appearance of prettier we have to add some files from our side. 
create .prettierrc

create .prettierignore

////////End of professional backend file folder structure setup///////////

/////////////////DATABASE CONNECTION/////////////////////
*********HOW TO CONNECT DATABASE IN MERN **************

to enter into mongodb from the atlas we need two things:
1. you op address must be allowed and you must have correct id and password  
-in production grade we never say allow access from anywhere in the ip address 
-in professional way ip address is added of that machine where you have all the backend codes   
2. a string as well

After that goto env
then next step is to create database name in constants

Database connection can be in 2 major ways:
    -place all code in the index file and when index file loads then the function in which database code is written will get execute
    -make db named file and write all function there and then import that file into the index file and then execute

app.js will be through express and database connection will be through mongoose.

install mongoose express dotenv packages

goto index and import mongoose

**********IMPORTTANT NOTE REGARDING DATABASE**************
1. Always wrap code in the try catch method. Because when we try to acess database there might be problem or you can do promises
2. "Database is always in another continent" it means when we talk to database it takes time which means always put async, await
*******************************************************

Using second approach create file in db folder.
export that

then import that in index.js

As early as possible in your application import and configure dotenv 
jati chado application load bho teti chado environment variable must be available 
if we load first file we want to load environment variable in that specific file. 


require('dotenv').config() place this in index.js
but in consistent formatting

also goto package.json and in scripts write experimental-json-module



****** First install dependencies mongoose dotenv and express 
create file in db folder.
also you have to goto env and set port and mongodb uri
then goto constants.js and export database name
then come to index
import that db file and run the function example connectDB()
also import dotenv and by doing dotenv.config ......
then goto the directory file ex: cd src then do npm run dev 
you will see message wriiten in db file i.e mongodb connection successful

/******1. Install Dependencies
    Run npm install express mongoose dotenv
2. Setup Environment Variables
    Create a .env file in the root directory
    Set PORT=5000 and MONGODB_URI=<your-mongodb-connection-string>
3. Create a Database Connection File
    Inside the db folder, create a db.js file
    Import mongoose and write a function to connect MongoDB
    Use process.env.MONGODB_URI to connect to the database
    Log a success message on connection
    Handle errors properly and exit the process if connection fails 
    Export the connection function
4. Export Database Name in Constants File
    Create constants.js
    Export DB_NAME with your database name
5. Setup Main Server File (index.js)
    Import dotenv, express, and the database connection file
    Call dotenv.config() to load environment variables
    Run the connectDB() function to establish the database connection
    Define the PORT from .env with a fallback
    Start the server and log a success message
6. Run the Server
    Navigate to the src directory using cd src
    Run npm run dev to start the server
7. Expected Output
    Console should display:
    MongoDB Connected: <your-cluster-url>
    Server running on port 5000
    ***********////////


*****CUSTOM API RESPONSE AND ERROR HANDLING********

goto app.js
Note: if async method completes it technically returns promise as well

It's useful to note that async functions return promises, 
and when using .then() and .catch(), it helps handle the result of these promises (i.e., success or failure).

goto index then write .then() and .catch()

install package:
    cookie-parser:
    cors: allows settings for all the cross origin resourse sharing

Middleware: they are the functions that are used to modify the request and response objects or have the access to request and response
Note: If you are using middlewares most of the time you use app.use other than app.get app.post 
to apply middleware to all routes or specific routes

Call both packages in app

so data might come from anywhere so we have to do preparation 
urls, json, forms, etc...

example:middleware like express.urlencoded() is useful to decode characters properly (like %20 for space). when data comes from URLs.

do it in app.js

if data comes from url there may be some issue 
url has its own encoder that converts the special characters like space=%20
for that do configuration app.use .....

some middlewares are essential for working with incoming data, 
e.g., express.json() for parsing JSON data, and express.urlencoded() for parsing URL-encoded form data.
Middlewares runs in the order they're defined in the app.

middleware example: if we goto /instagram then after going instagram req.send("gaurav") is seen on the profile.
but during that the function that runs after logging in instagram that checks if user is logged in or if the user is admin
is an example of middlewares. 

video stopped at 19:15 of video no 9.

starts:

we have studied till this only about req and res but there is also err and next i.e 4elements. (err, req, res, next)
next: if we use next then we are talking about middlewares

we are interacting with database numerous number of times so instead of writing code several times why dont we create utility file
that consists of generalized functions.
so when we need to execute these functions pass the function in the method and then it will execute and pass

GOTO utils folder create file asyncHandler

if you want to standardize the api error and response
(search on web nodejs api errors)

video stopped at 36:00

create utils file named ApiError to handle all types of error encountered in the website

NOTE: difference between export {anyname}, export const anyname, export default anyname
export {anyname} :
import syntax: import {anyname} from ..
can be multiple exported within same file
used when you need to export multiple things from same file ///Common use case: api services, utility functions, reusable components

export const anyname:
import syntax: import {anyname} from ..
can have multiple exports
used when you have to declare and export at the same time. // Common use exporting constants , classes, utility functions

export default anyname:
import syntax: import anyname from 
can have only one export per file
used when module is mainly about one thing eg function class or component // Common use Main utility functions, react components ...

similarly create file in utils named apiresponse for handling all the api responses.

now write middleware where when this type of error comes then it always should go through api error.


/////////////**************USER AND VIDEO MODELS WITH HOOKS AND JWT**********/////////

goto models and create new file user.model.js (you can write any user.js or user.model.js depending upon you)
also video.model.js

Note:// schema is an Object Data Modeling (ODM) library for MongoDB and Node.js.
//defines the structure of the documents within mongodb collection.

create schema for both user and model

Note: now we use special package: mongoose-aggregate-paginate-v2
It allows to write aggregation queries. 

install that package
It is injected as plugin
-written before export

import that and added within plugin

now we can write aggregation queries.

video stopped at 23:25

download bcrypt package, jsonwebtoken
(Bcrypt is a library that helps you to hash your password)
(jsonwebtoken encodes user info into a token, which can be verified without storing session data on server.)

import both in user.

how to encrypt?
we have to take help from mongoose hooks

pre hook: when you data is going to be saved, then just before that we can run such that those datas/password are encrypted

Note: these hooks are present mainly in models files in professional code

Note: in arrow function , it doesnot have this reference i.e it doesnot have the knowledge of particular context.
But in pre hook the need of knowing context is very important.

bcrypt can hash password but it can check password as well

video stops at 37:25

JWT: it is a bearer token. it means whoever has this token then the data is sent to that person. just like the key.

create access token secret in environment variables.
also create referesh token 

we are using both session and cookies
access token will not be stored in the database but referesh token will be stored in database

payload: what are the informations that to be put

///////////////*********************END OF THE VIDEO**********///////////////// 